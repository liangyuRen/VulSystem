package com.nju.backend.service.vulnerability;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.nju.backend.repository.mapper.*;
import com.nju.backend.repository.po.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.HttpServerErrorException;
import org.springframework.web.client.RestClientException;
import org.springframework.web.client.RestTemplate;

import java.util.*;
import java.util.stream.Collectors;

/**
 * 漏洞检测服务
 * 负责调用Flask API进行漏洞检测，并将结果存储到数据库
 */
@Service
public class VulnerabilityDetectionService {

    @Autowired
    private CompanyMapper companyMapper;

    @Autowired
    private WhiteListMapper whiteListMapper;

    @Autowired
    private ProjectMapper projectMapper;

    @Autowired
    private VulnerabilityMapper vulnerabilityMapper;

    @Autowired
    private VulnerabilityReportMapper vulnerabilityReportMapper;

    @Autowired
    private VulnerabilityReportVulnerabilityMapper vulnerabilityReportVulnerabilityMapper;

    @Autowired
    private ProjectVulnerabilityMapper projectVulnerabilityMapper;

    @Autowired
    private RestTemplate restTemplate;

    private static final String FLASK_DETECT_URL = "http://localhost:5000/vulnerabilities/detect";

    // 支持的语言列表
    private static final List<String> SUPPORTED_LANGUAGES = Arrays.asList(
        "java", "c", "python", "php", "ruby", "go", "rust", "javascript", "erlang"
    );

    /**
     * 为指定公司和语言执行漏洞检测
     *
     * @param companyId 公司ID
     * @param language 语言类型
     * @param vulnerabilityReports 漏洞报告列表
     * @return 检测结果统计
     */
    @Transactional
    public Map<String, Object> detectVulnerabilitiesForCompanyAndLanguage(
            int companyId,
            String language,
            List<VulnerabilityReport> vulnerabilityReports) {

        Map<String, Object> result = new HashMap<>();
        int processedCount = 0;
        int detectedCount = 0;
        List<String> errors = new ArrayList<>();

        System.out.println("========================================");
        System.out.println("开始漏洞检测");
        System.out.println("公司ID: " + companyId);
        System.out.println("语言: " + language);
        System.out.println("漏洞报告数量: " + vulnerabilityReports.size());
        System.out.println("========================================");

        // 获取公司信息
        Company company = companyMapper.selectById(companyId);
        if (company == null) {
            result.put("error", "公司不存在: " + companyId);
            return result;
        }

        // 从white_list表获取该公司的组件列表
        String whiteListJson = getWhiteListFromDatabase(companyId, language);

        if (whiteListJson == null || whiteListJson.equals("[]") || whiteListJson.isEmpty()) {
            result.put("warning", "公司 " + company.getName() + " 没有 " + language + " 语言的依赖组件");
            result.put("processedCount", 0);
            result.put("detectedCount", 0);
            return result;
        }

        System.out.println("获取到白名单组件数量: " + whiteListJson);

        // 遍历每个漏洞报告进行检测
        for (VulnerabilityReport vulnerabilityReport : vulnerabilityReports) {
            try {
                // 确保漏洞名称不为空
                extractVulnerabilityNameIfEmpty(vulnerabilityReport);

                // 调用Flask API进行检测
                String matchedComponents = callFlaskDetectionAPI(
                    vulnerabilityReport,
                    company,
                    language,
                    whiteListJson
                );

                if (matchedComponents != null && !matchedComponents.trim().isEmpty()) {
                    // 存储检测结果到数据库
                    int savedCount = saveDetectionResults(
                        vulnerabilityReport,
                        matchedComponents,
                        whiteListJson,
                        language,
                        company.getMaxDetectNums()
                    );

                    detectedCount += savedCount;
                    System.out.println("CVE " + vulnerabilityReport.getCveId() +
                        " 检测到 " + savedCount + " 个有漏洞的组件");
                }

                processedCount++;

            } catch (Exception e) {
                String errorMsg = "处理漏洞报告失败: " + vulnerabilityReport.getCveId() +
                    ", 错误: " + e.getMessage();
                errors.add(errorMsg);
                System.err.println(errorMsg);
                e.printStackTrace();
            }
        }

        result.put("processedCount", processedCount);
        result.put("detectedCount", detectedCount);
        result.put("company", company.getName());
        result.put("language", language);
        if (!errors.isEmpty()) {
            result.put("errors", errors);
        }

        System.out.println("========================================");
        System.out.println("漏洞检测完成");
        System.out.println("处理漏洞数: " + processedCount);
        System.out.println("检测到有漏洞的组件数: " + detectedCount);
        System.out.println("========================================");

        return result;
    }

    /**
     * 为所有公司和所有语言执行漏洞检测
     *
     * @param vulnerabilityReports 漏洞报告列表
     * @return 检测结果统计
     */
    @Transactional
    public Map<String, Object> detectVulnerabilitiesForAll(List<VulnerabilityReport> vulnerabilityReports) {
        Map<String, Object> overallResult = new HashMap<>();
        List<Map<String, Object>> detailResults = new ArrayList<>();
        int totalProcessed = 0;
        int totalDetected = 0;

        List<Company> companies = companyMapper.selectList(null);

        System.out.println("========================================");
        System.out.println("开始全量漏洞检测");
        System.out.println("公司数量: " + companies.size());
        System.out.println("支持的语言: " + SUPPORTED_LANGUAGES);
        System.out.println("漏洞报告数量: " + vulnerabilityReports.size());
        System.out.println("========================================");

        for (Company company : companies) {
            for (String language : SUPPORTED_LANGUAGES) {
                Map<String, Object> result = detectVulnerabilitiesForCompanyAndLanguage(
                    company.getId(),
                    language,
                    vulnerabilityReports
                );

                if (result.containsKey("processedCount")) {
                    int processed = (int) result.get("processedCount");
                    int detected = (int) result.get("detectedCount");

                    if (processed > 0 || detected > 0) {
                        detailResults.add(result);
                        totalProcessed += processed;
                        totalDetected += detected;
                    }
                }
            }
        }

        overallResult.put("totalProcessed", totalProcessed);
        overallResult.put("totalDetected", totalDetected);
        overallResult.put("companiesCount", companies.size());
        overallResult.put("languagesCount", SUPPORTED_LANGUAGES.size());
        overallResult.put("details", detailResults);

        System.out.println("========================================");
        System.out.println("全量漏洞检测完成");
        System.out.println("总处理漏洞数: " + totalProcessed);
        System.out.println("总检测到有漏洞的组件数: " + totalDetected);
        System.out.println("========================================");

        return overallResult;
    }

    /**
     * 从数据库获取白名单组件列表（JSON格式）
     */
    private String getWhiteListFromDatabase(int companyId, String language) {
        try {
            ObjectMapper mapper = new ObjectMapper();

            // 1. 获取公司信息和项目ID列表
            Company company = companyMapper.selectById(companyId);
            if (company == null || company.getProjectId() == null) {
                System.out.println("公司ID " + companyId + " 不存在或没有关联项目");
                return "[]";
            }

            // 2. 解析projectId JSON字段获取项目ID列表
            JsonNode projectIdJson = mapper.readTree(company.getProjectId());
            List<Integer> projectIds = new ArrayList<>();

            Iterator<String> fieldNames = projectIdJson.fieldNames();
            while (fieldNames.hasNext()) {
                String projectIdStr = fieldNames.next();
                try {
                    projectIds.add(Integer.parseInt(projectIdStr));
                } catch (NumberFormatException e) {
                    System.out.println("无法解析项目ID: " + projectIdStr);
                }
            }

            if (projectIds.isEmpty()) {
                System.out.println("公司 " + company.getName() + " 没有关联的项目");
                return "[]";
            }

            // 3. 查询项目详情获取文件路径
            List<Project> projects = projectMapper.selectBatchIds(projectIds);
            if (projects.isEmpty()) {
                System.out.println("公司 " + company.getName() + " 的项目信息未找到");
                return "[]";
            }

            List<String> projectPaths = projects.stream()
                .map(Project::getFile)
                .filter(file -> file != null && !file.isEmpty())
                .collect(Collectors.toList());

            if (projectPaths.isEmpty()) {
                System.out.println("公司 " + company.getName() + " 的项目没有文件路径");
                return "[]";
            }

            // 4. 查询这些项目的依赖（指定语言）
            List<WhiteList> whiteLists = whiteListMapper.selectList(
                new QueryWrapper<WhiteList>()
                    .in("file_path", projectPaths)
                    .eq("language", language)
                    .eq("isdelete", 0)
            );

            if (whiteLists.isEmpty()) {
                System.out.println("公司 " + company.getName() + " 没有 " + language + " 语言的依赖");
                return "[]";
            }

            // 5. 构建JSON格式（符合Flask API期望的格式）
            List<Map<String, String>> result = new ArrayList<>();
            for (WhiteList wl : whiteLists) {
                Map<String, String> item = new HashMap<>();
                item.put("name", wl.getName());
                item.put("language", wl.getLanguage());

                // 根据file_path找到对应的project_id
                Project project = projects.stream()
                    .filter(p -> p.getFile().equals(wl.getFilePath()))
                    .findFirst()
                    .orElse(null);

                if (project != null) {
                    item.put("pojectid", String.valueOf(project.getId()));
                    result.add(item);
                }
            }

            String jsonResult = mapper.writeValueAsString(result);
            System.out.println("公司 " + company.getName() + " 的 " + language +
                " 依赖数量: " + result.size());
            return jsonResult;

        } catch (Exception e) {
            System.err.println("从数据库查询白名单失败: " + e.getMessage());
            e.printStackTrace();
            return "[]";
        }
    }

    /**
     * 调用Flask API进行漏洞检测
     */
    private String callFlaskDetectionAPI(
            VulnerabilityReport vulnerabilityReport,
            Company company,
            String language,
            String whiteListJson) {

        try {
            // 创建请求参数
            Map<String, String> params = new HashMap<>();
            params.put("cve_id", vulnerabilityReport.getCveId());
            params.put("desc", vulnerabilityReport.getDescription());
            params.put("white_list", whiteListJson);
            params.put("company", company.getName());
            params.put("detect_strategy", company.getDetectStrategy());
            params.put("similarityThreshold", company.getSimilarityThreshold().toString());
            params.put("language", language);

            // 设置HTTP头
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_JSON);

            // 创建HTTP实体
            HttpEntity<Map<String, String>> requestEntity = new HttpEntity<>(params, headers);

            System.out.println("调用Flask API: " + FLASK_DETECT_URL);
            System.out.println("CVE: " + vulnerabilityReport.getCveId());
            System.out.println("语言: " + language);

            // 发送POST请求
            ResponseEntity<String> response = restTemplate.exchange(
                FLASK_DETECT_URL,
                HttpMethod.POST,
                requestEntity,
                String.class
            );

            // 检查响应
            if (!response.getStatusCode().is2xxSuccessful()) {
                System.err.println("API调用失败，状态码: " + response.getStatusCode());
                return null;
            }

            String labels = response.getBody();

            if (labels == null || labels.trim().isEmpty()) {
                System.out.println("API返回空结果，CVE: " + vulnerabilityReport.getCveId());
                return null;
            }

            // 检查是否返回了错误页面
            if (labels.contains("<!doctype html>") || labels.contains("<html")) {
                System.err.println("API返回错误页面");
                return null;
            }

            System.out.println("API调用成功，匹配到的组件: " + labels);
            return labels;

        } catch (HttpServerErrorException e) {
            System.err.println("Flask服务返回5xx错误: " + e.getMessage());
            e.printStackTrace();
            return null;
        } catch (HttpClientErrorException e) {
            System.err.println("Flask服务返回4xx错误: " + e.getMessage());
            e.printStackTrace();
            return null;
        } catch (RestClientException e) {
            System.err.println("REST调用异常: " + e.getMessage());
            e.printStackTrace();
            return null;
        } catch (Exception e) {
            System.err.println("API调用出现未预期的异常: " + e.getMessage());
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 保存检测结果到数据库
     */
    private int saveDetectionResults(
            VulnerabilityReport vulnerabilityReport,
            String matchedComponents,
            String whiteListJson,
            String language,
            int maxDetectNum) {

        int savedCount = 0;

        try {
            ObjectMapper objectMapper = new ObjectMapper();

            // 1. 保存或更新漏洞报告
            VulnerabilityReport existingReport = vulnerabilityReportMapper.selectById(vulnerabilityReport.getId());
            if (existingReport == null) {
                vulnerabilityReportMapper.insert(vulnerabilityReport);
                System.out.println("插入新漏洞报告，CVE: " + vulnerabilityReport.getCveId());
            } else {
                System.out.println("漏洞报告已存在，CVE: " + vulnerabilityReport.getCveId());
            }

            // 2. 解析匹配的组件列表
            List<String> componentList = Arrays.asList(matchedComponents.split(";"));

            // 根据maxDetectNum做截断
            if (componentList.size() > maxDetectNum) {
                componentList = componentList.subList(0, maxDetectNum);
            }

            // 3. 解析白名单JSON
            JsonNode whiteListArray = objectMapper.readTree(whiteListJson);

            // 4. 遍历白名单，为匹配的组件创建漏洞记录
            for (JsonNode whiteListItem : whiteListArray) {
                String componentName = whiteListItem.get("name").asText();
                String projectId = whiteListItem.get("pojectid").asText();

                if (componentList.contains(componentName)) {
                    // 创建漏洞记录
                    Vulnerability vulnerability = new Vulnerability();
                    vulnerability.setDescription(vulnerabilityReport.getDescription());
                    vulnerability.setIsAccept(0);
                    vulnerability.setIsDelete(0);
                    vulnerability.setName(vulnerabilityReport.getVulnerabilityName());
                    vulnerability.setRiskLevel(vulnerabilityReport.getRiskLevel());
                    vulnerability.setTime(vulnerabilityReport.getDisclosureTime());
                    vulnerability.setLanguage(language);
                    vulnerability.setRef(vulnerabilityReport.getCveId());
                    vulnerabilityMapper.insert(vulnerability);

                    // 创建漏洞报告-漏洞关联
                    VulnerabilityReportVulnerability vrv = new VulnerabilityReportVulnerability();
                    vrv.setVulnerabilityId(vulnerability.getId());
                    vrv.setVulnerabilityReportId(vulnerabilityReport.getId());
                    vrv.setIsDelete(0);
                    vulnerabilityReportVulnerabilityMapper.insert(vrv);

                    // 创建项目-漏洞关联
                    ProjectVulnerability pv = new ProjectVulnerability();
                    pv.setVulnerabilityId(vulnerability.getId());
                    pv.setProjectId(Integer.parseInt(projectId));
                    pv.setIsDelete(0);
                    projectVulnerabilityMapper.insert(pv);

                    savedCount++;

                    System.out.println("保存漏洞记录: " + componentName +
                        " (项目ID: " + projectId + ", CVE: " + vulnerabilityReport.getCveId() + ")");
                }
            }

        } catch (Exception e) {
            System.err.println("保存检测结果失败: " + e.getMessage());
            e.printStackTrace();
        }

        return savedCount;
    }

    /**
     * 如果漏洞名称为空，从描述中提取
     */
    private void extractVulnerabilityNameIfEmpty(VulnerabilityReport report) {
        if (report.getVulnerabilityName() == null || report.getVulnerabilityName().trim().isEmpty()) {
            String description = report.getDescription();
            if (description != null && !description.isEmpty()) {
                // 提取描述的前50个字符作为漏洞名称
                String extracted = description.length() > 50 ?
                    description.substring(0, 50) + "..." : description;
                report.setVulnerabilityName(extracted);
            } else {
                report.setVulnerabilityName("未知漏洞 - " + report.getCveId());
            }
        }
    }
}
