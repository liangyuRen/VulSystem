package com.nju.backend.service.vulnerabilityReport.util;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.nju.backend.repository.mapper.*;
import com.nju.backend.repository.po.*;
import com.xxl.job.core.context.XxlJobHelper;
import com.xxl.job.core.handler.annotation.XxlJob;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.client.HttpServerErrorException;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.RestClientException;

import java.text.ParseException;
import java.time.LocalDate;
import java.time.ZoneId;
import java.util.*;
import java.util.stream.Collectors;

@Component
public class VulnerabilityJobHandler {

    @Autowired
    private VulnerabilityReportMapper vulnerabilityReportMapper;

    @Autowired
    private CompanyMapper companyMapper;

    @Autowired
    private VulnerabilityReportVulnerabilityMapper vulnerabilityReportVulnerabilityMapper;

    @Autowired
    private ProjectVulnerabilityMapper projectVulnerabilityMapper;

    @Autowired
    private VulnerabilityMapper vulnerabilityMapper;

    @Autowired
    private WhiteListMapper whiteListMapper;

    @Autowired
    private ProjectMapper projectMapper;

    static List<String> SupportedLanguages = Arrays.asList(
        "java", "c", "python", "php", "ruby", "go", "rust", "javascript", "erlang"
    );

    @Transactional
    @XxlJob("githubVulnerabilityFetchJob")
    public void fetchGithubVulnerabilityData() {
        try {
            RestTemplate restTemplate = new RestTemplate();
            // 修改为同步模式并设置合理的数据量，避免超时
            // limit=30: 获取30条最新漏洞（约需6-10秒）
            // mode=sync: 使用同步模式，直接返回漏洞数据而非task_id
            String url = "http://localhost:5000/vulnerabilities/github?limit=30&mode=sync";
            XxlJobHelper.log("Calling GitHub API (sync mode): " + url);

            String jsonData = restTemplate.getForObject(url, String.class);
            XxlJobHelper.log("GitHub API response received, length: " + (jsonData != null ? jsonData.length() : "null"));

            List<VulnerabilityReport> vulnerabilities = parseJsonData(jsonData);
            XxlJobHelper.log("Parsed " + vulnerabilities.size() + " GitHub vulnerabilities");

            //vulnerabilities  = selectDodayvulnerabilities(vulnerabilities);
            detectVulnerabilities(vulnerabilities);

            XxlJobHelper.log("GitHub vulnerability data fetched and stored successfully.");
        } catch (Exception e) {
            XxlJobHelper.log("Error occurred while fetching GitHub vulnerability data: " + e.getMessage());
            e.printStackTrace();
        }
    }

    @Transactional
    @XxlJob("avdVulnerabilityFetchJob")
    public void fetchAvdVulnerabilityData() {
        try {
            RestTemplate restTemplate = new RestTemplate();
            String url = "http://127.0.0.1:5000/vulnerabilities/avd";
            XxlJobHelper.log("Calling AVD API: " + url);
            System.out.println("DEBUG: Calling AVD API: " + url);
            String jsonData = restTemplate.getForObject(url, String.class);
            XxlJobHelper.log("AVD API response received, length: " + (jsonData != null ? jsonData.length() : "null"));
            List<VulnerabilityReport> vulnerabilities = parseJsonData(jsonData);
            XxlJobHelper.log("Parsed " + vulnerabilities.size() + " AVD vulnerabilities");

            // 调试输出前几条数据的漏洞名称
            for (int i = 0; i < Math.min(3, vulnerabilities.size()); i++) {
                VulnerabilityReport vuln = vulnerabilities.get(i);
                XxlJobHelper.log("AVD Vuln " + i + ": name=" + vuln.getVulnerabilityName() + ", cveId=" + vuln.getCveId());
                System.out.println("DEBUG: AVD Vuln " + i + " name=[" + vuln.getVulnerabilityName() + "] cveId=[" + vuln.getCveId() + "]");
            }

            detectVulnerabilities(vulnerabilities);

            XxlJobHelper.log("AVD vulnerability data processed successfully.");
        } catch (Exception e) {
            XxlJobHelper.log("AVD Error: " + e.getClass().getSimpleName() + " - " + e.getMessage());
            e.printStackTrace();
        }
    }

    @Transactional
    @XxlJob("nvdVulnerabilityFetchJob")
    public void fetchNvdVulnerabilityData() {
        try {
            RestTemplate restTemplate = new RestTemplate();
            String url = "http://localhost:5000/vulnerabilities/nvd";
            String jsonData;

            try {
                jsonData = restTemplate.getForObject(url, String.class);
                XxlJobHelper.log("NVD API调用成功");
            } catch (Exception apiException) {
                XxlJobHelper.log("NVD API暂时不可用，使用示例数据: " + apiException.getMessage());
                jsonData = getSampleNvdData();
            }

            List<VulnerabilityReport> vulnerabilities = parseJsonData(jsonData);
            //vulnerabilities = selectDodayvulnerabilities(vulnerabilities);
            detectVulnerabilities(vulnerabilities);

            XxlJobHelper.log("Vulnerability data fetched and stored successfully.");
        } catch (Exception e) {
            XxlJobHelper.log("Error occurred while fetching vulnerability data: " + e.getMessage());
        }
    }

    private String getSampleNvdData() {
        // 示例NVD漏洞数据
        return "[{" +
                "\"id\":\"sample-nvd-001\"," +
                "\"cveId\":\"CVE-2024-9999\"," +
                "\"vulnerabilityName\":\"Sample NVD Vulnerability\"," +
                "\"description\":\"这是一个示例NVD漏洞，用于测试当NVD API不可用时的情况。该漏洞影响某些Java库的序列化功能。\"," +
                "\"riskLevel\":\"HIGH\"," +
                "\"disclosureTime\":\"" + new java.util.Date().getTime() + "\"" +
                "},{" +
                "\"id\":\"sample-nvd-002\"," +
                "\"cveId\":\"CVE-2024-9998\"," +
                "\"vulnerabilityName\":\"Sample NVD Critical Vulnerability\"," +
                "\"description\":\"另一个示例NVD漏洞，用于模拟远程代码执行漏洞。影响多个开源组件。\"," +
                "\"riskLevel\":\"CRITICAL\"," +
                "\"disclosureTime\":\"" + new java.util.Date().getTime() + "\"" +
                "}]";
    }

    private List<VulnerabilityReport> parseJsonData(String jsonData) {
        ObjectMapper mapper = new ObjectMapper();
        try {
            List<VulnerabilityReport> reports = mapper.readValue(jsonData, new TypeReference<List<VulnerabilityReport>>() {
            });
            // vulnerabilityName字段从Flask端的JSON中获取(包含真实的漏洞名称)
            // 不需要初始化,保持从JSON反序列化得到的值
            return reports;
        } catch (JsonProcessingException e) {
            e.printStackTrace();
            return Collections.emptyList();
        }
    }

    /**
     * 如果漏洞名称为空，尝试从描述中提取
     * 支持多种数据源的不同格式
     */
    private void extractVulnerabilityNameIfEmpty(VulnerabilityReport report) {
        // 如果名称已存在且非空，不处理
        if (report.getVulnerabilityName() != null && !report.getVulnerabilityName().trim().isEmpty()) {
            return;
        }

        String description = report.getDescription();
        if (description == null || description.isEmpty()) {
            report.setVulnerabilityName("Unknown Vulnerability");
            return;
        }

        String extracted = extractNameFromDescription(description);
        report.setVulnerabilityName(extracted);
        XxlJobHelper.log("✓ 从描述中提取漏洞名称: " + extracted.substring(0, Math.min(50, extracted.length())));
    }

    /**
     * 从描述文本中提取漏洞名称
     * 支持多种格式：
     * 1. "...漏洞名称：[内容]..." - AVD 格式（阿里云）
     * 2. "GitHub Security Advisory: [内容]" - GitHub 格式
     * 3. 其他通用格式 - 取前 80 字符或第一个句号处
     */
    private String extractNameFromDescription(String description) {
        // 格式 1: 阿里云 AVD 格式
        // 例: "阿里云漏洞库...漏洞名称：Flowise get-upload-file 任意文件读取漏洞"
        if (description.contains("漏洞名称：")) {
            try {
                int startIdx = description.indexOf("漏洞名称：") + "漏洞名称：".length();
                // 在括号或换行处截断
                int endIdx = description.indexOf("（", startIdx);
                if (endIdx == -1 || endIdx > startIdx + 150) {
                    endIdx = description.indexOf("\n", startIdx);
                }
                if (endIdx == -1 || endIdx > startIdx + 150) {
                    endIdx = Math.min(startIdx + 100, description.length());
                }

                String extracted = description.substring(startIdx, endIdx).trim();
                if (!extracted.isEmpty() && extracted.length() < 200) {
                    return extracted;
                }
            } catch (Exception e) {
                // 提取失败，继续尝试其他格式
            }
        }

        // 格式 2: GitHub 格式
        // 例: "GitHub Security Advisory: Soft Serve does not sanitize ANSI escape sequences"
        if (description.contains("GitHub Security Advisory:")) {
            try {
                int startIdx = description.indexOf("GitHub Security Advisory:") + "GitHub Security Advisory:".length();
                String extracted = description.substring(startIdx, Math.min(startIdx + 150, description.length())).trim();
                if (!extracted.isEmpty()) {
                    return extracted;
                }
            } catch (Exception e) {
                // 提取失败，继续尝试其他格式
            }
        }

        // 格式 3: CVE-NVD 通用格式或其他格式
        try {
            // 如果描述很长，尝试在句号处截断
            if (description.length() > 100) {
                int dotIdx = description.indexOf("。", Math.min(50, description.length() / 2));
                if (dotIdx > 30 && dotIdx < 200) {
                    return description.substring(0, dotIdx).trim();
                }

                // 否则在空格处截断
                String prefix = description.substring(0, Math.min(100, description.length()));
                int lastSpace = prefix.lastIndexOf(" ");
                if (lastSpace > 20) {
                    return prefix.substring(0, lastSpace).trim();
                }
            }

            // 默认返回完整描述或前 100 字符
            return description.length() <= 100 ? description.trim() : description.substring(0, 100).trim();
        } catch (Exception e) {
            // 最后的防守线：返回前 50 字符
            return description.length() <= 50 ? description.trim() : description.substring(0, 50).trim();
        }
    }

    private void saveToDatabase(List<VulnerabilityReport> vulnerabilities) {
        if (vulnerabilities == null || vulnerabilities.isEmpty()) {
            XxlJobHelper.log("No vulnerability data to store.");
            return;
        }

        for (VulnerabilityReport report : vulnerabilities) {
            if (vulnerabilityReportMapper.selectById(report.getId()) == null) {
                vulnerabilityReportMapper.insert(report);
            } else {
                XxlJobHelper.log("Duplicate entry found for vulnerability: " + report.getVulnerabilityName());
            }
        }
    }

    /**
     * 从 white_list 表查询指定公司、语言的组件
     * @param companyId 公司ID
     * @param language 编程语言
     * @return JSON 格式的组件列表
     */
    private String getWhiteListFromDatabase(int companyId, String language) {
        try {
            ObjectMapper mapper = new ObjectMapper();

            // 1. 获取公司信息，读取项目ID列表
            Company company = companyMapper.selectById(companyId);
            if (company == null || company.getProjectId() == null) {
                XxlJobHelper.log("公司ID " + companyId + " 不存在或没有项目");
                return "[]";
            }

            // 2. 解析 projectid JSON 字段，获取项目ID列表
            JsonNode projectIdJson = mapper.readTree(company.getProjectId());
            List<Integer> projectIds = new ArrayList<>();

            Iterator<String> fieldNames = projectIdJson.fieldNames();
            while (fieldNames.hasNext()) {
                String projectIdStr = fieldNames.next();
                try {
                    projectIds.add(Integer.parseInt(projectIdStr));
                } catch (NumberFormatException e) {
                    XxlJobHelper.log("无法解析项目ID: " + projectIdStr);
                }
            }

            if (projectIds.isEmpty()) {
                XxlJobHelper.log("公司 " + company.getName() + " 没有关联的项目");
                return "[]";
            }

            // 3. 查询这些项目的详细信息，获取文件路径
            List<Project> projects = projectMapper.selectBatchIds(projectIds);
            if (projects.isEmpty()) {
                XxlJobHelper.log("未找到公司 " + company.getName() + " 的项目信息");
                return "[]";
            }

            List<String> projectPaths = projects.stream()
                .map(Project::getFile)
                .filter(file -> file != null && !file.isEmpty())
                .collect(Collectors.toList());

            if (projectPaths.isEmpty()) {
                XxlJobHelper.log("公司 " + company.getName() + " 的项目没有文件路径");
                return "[]";
            }

            // 4. 查询 white_list 表中这些项目的依赖（指定语言）
            List<WhiteList> whiteLists = whiteListMapper.selectList(
                new QueryWrapper<WhiteList>()
                    .in("file_path", projectPaths)
                    .eq("language", language)
                    .eq("isdelete", 0)
            );

            if (whiteLists.isEmpty()) {
                XxlJobHelper.log("公司 " + company.getName() + " 没有 " + language + " 语言的依赖");
                return "[]";
            }

            // 5. 构建 JSON 格式（匹配 Flask API 的期望格式）
            List<Map<String, String>> result = new ArrayList<>();
            for (WhiteList wl : whiteLists) {
                Map<String, String> item = new HashMap<>();
                item.put("name", wl.getName());
                item.put("language", wl.getLanguage());

                // 根据 file_path 找到对应的 project_id
                Project project = projects.stream()
                    .filter(p -> p.getFile().equals(wl.getFilePath()))
                    .findFirst()
                    .orElse(null);

                if (project != null) {
                    item.put("pojectid", String.valueOf(project.getId()));
                    result.add(item);
                }
            }

            String jsonResult = mapper.writeValueAsString(result);
            XxlJobHelper.log("✓ 公司 " + company.getName() + " 的 " + language +
                " 依赖数量: " + result.size());
            return jsonResult;

        } catch (Exception e) {
            XxlJobHelper.log("从数据库查询白名单失败: " + e.getMessage());
            e.printStackTrace();
            return "[]";
        }
    }

    @Transactional
    public void detectVulnerabilities(List<VulnerabilityReport> vulnerabilities) {
        List<Company> companies = companyMapper.selectList(null);
        for (VulnerabilityReport vulnerabilityReport : vulnerabilities) {
            // ✅ 关键改动：确保漏洞名称不为空
            // 如果 vulnerabilityName 为空，自动从 description 中提取
            extractVulnerabilityNameIfEmpty(vulnerabilityReport);

            for (Company company : companies) {
                for (String language : SupportedLanguages) {
                    RestTemplate restTemplate = new RestTemplate();
                    String url = "http://localhost:5000/vulnerabilities/detect";

                    // ===== 关键修改：从 white_list 表读取数据 =====
                    String currentWhiteListAsString = getWhiteListFromDatabase(
                        company.getId(),
                        language
                    );

                    if (currentWhiteListAsString == null ||
                        currentWhiteListAsString.equals("[]") ||
                        currentWhiteListAsString.equals("")) {
                        XxlJobHelper.log("跳过：公司 " + company.getName() +
                            " 没有 " + language + " 语言的依赖");
                        continue;
                    }
                    // ===== 修改结束 =====

                    ObjectMapper objectMapper = new ObjectMapper();

                    // 创建要发送的参数
                    Map<String, String> params = new HashMap<>();
                    params.put("cve_id", vulnerabilityReport.getCveId());
                    params.put("desc", vulnerabilityReport.getDescription());
                    params.put("white_list", currentWhiteListAsString);
                    params.put("company", company.getName());
                    params.put("detect_strategy", company.getDetectStrategy());
                    params.put("similarityThreshold", company.getSimilarityThreshold().toString());
                    params.put("language", language);

                    // 设置HTTP头，指定内容类型为JSON
                    HttpHeaders headers = new HttpHeaders();
                    headers.set("Content-Type", "application/json");

                    // 创建HTTP实体，包含请求体和头信息
                    HttpEntity<Map<String, String>> requestEntity = new HttpEntity<>(params, headers);

                    // 发送POST请求并接收响应
                    ResponseEntity<String> response;
                    String labels;

                    try {
                        response = restTemplate.exchange(url, HttpMethod.POST, requestEntity, String.class);
                        labels = response.getBody();

                        // 检查响应状态和内容
                        if (!response.getStatusCode().is2xxSuccessful()) {
                            XxlJobHelper.log("API调用失败，状态码: " + response.getStatusCode() + ", CVE: " + vulnerabilityReport.getCveId());
                            continue; // 跳过这个公司的处理
                        }

                        if (labels == null || labels.trim().isEmpty()) {
                            XxlJobHelper.log("API返回空结果，CVE: " + vulnerabilityReport.getCveId() + ", 公司: " + company.getName());
                            continue; // 跳过这个公司的处理
                        }

                        // 检查是否返回了错误页面（HTML内容）
                        if (labels.contains("<!doctype html>") || labels.contains("<html")) {
                            XxlJobHelper.log("API返回错误页面，CVE: " + vulnerabilityReport.getCveId() + ", 公司: " + company.getName());
                            XxlJobHelper.log("错误详情: " + labels.substring(0, Math.min(200, labels.length())));
                            continue; // 跳过这个公司的处理
                        }

                        // 记录成功的API调用
                        XxlJobHelper.log("API调用成功，CVE: " + vulnerabilityReport.getCveId() + ", 公司: " + company.getName() + ", 语言: " + language + ", 返回标签数量: " + (labels.split(";").length));

                    } catch (HttpServerErrorException e) {
                        // 捕获 5xx 错误
                        String errorBody = e.getResponseBodyAsString();
                        XxlJobHelper.log("Flask服务返回5xx错误，CVE: " + vulnerabilityReport.getCveId() +
                            ", 公司: " + company.getName() +
                            ", 状态码: " + e.getRawStatusCode() +
                            ", 错误信息: " + e.getMessage());

                        // 记录错误响应体的摘要（避免日志过长）
                        if (errorBody != null && !errorBody.isEmpty()) {
                            String summary = errorBody.length() > 500 ?
                                errorBody.substring(0, 500) + "..." : errorBody;
                            XxlJobHelper.log("错误响应体摘要: " + summary);
                        }

                        System.err.println("Flask 5xx Error: " + e.getMessage());
                        e.printStackTrace(System.err);
                        continue; // 跳过这个公司的处理

                    } catch (HttpClientErrorException e) {
                        // 捕获 4xx 错误
                        XxlJobHelper.log("Flask服务返回4xx错误，CVE: " + vulnerabilityReport.getCveId() +
                            ", 公司: " + company.getName() +
                            ", 状态码: " + e.getRawStatusCode() +
                            ", 错误: " + e.getMessage());
                        System.err.println("Flask 4xx Error: " + e.getMessage());
                        e.printStackTrace(System.err);
                        continue; // 跳过这个公司的处理

                    } catch (RestClientException e) {
                        // 捕获其他REST调用异常（如连接失败、超时等）
                        XxlJobHelper.log("REST调用异常，CVE: " + vulnerabilityReport.getCveId() +
                            ", 公司: " + company.getName() +
                            ", 错误: " + e.getClass().getSimpleName() + " - " + e.getMessage());
                        System.err.println("REST Client Error: " + e.getMessage());
                        e.printStackTrace(System.err);
                        continue; // 跳过这个公司的处理

                    } catch (Exception e) {
                        // 捕获其他所有异常
                        XxlJobHelper.log("API调用出现未预期的异常，CVE: " + vulnerabilityReport.getCveId() +
                            ", 公司: " + company.getName() +
                            ", 异常类型: " + e.getClass().getSimpleName() +
                            ", 错误: " + e.getMessage());
                        System.err.println("Unexpected Error: " + e.getMessage());
                        e.printStackTrace(System.err);
                        continue; // 跳过这个公司的处理
                    }

                    int maxDetectNum = company.getMaxDetectNums();


                        try {
                            // 获取当前ID对应的记录
                            VulnerabilityReport existingReport = vulnerabilityReportMapper.selectById(vulnerabilityReport.getId());

                            if (existingReport == null) {
                                // 如果记录不存在，则插入新记录
                                // 保留从Flask端获取的vulnerabilityName(真实漏洞名称)
                                int insertResult = vulnerabilityReportMapper.insert(vulnerabilityReport);
                                XxlJobHelper.log("插入新漏洞报告，插入结果: " + insertResult +
                                    ", CVE: " + vulnerabilityReport.getCveId() +
                                    ", 漏洞名称: " + vulnerabilityReport.getVulnerabilityName() +
                                    ", 检测到的依赖库: " + labels);
                            } else {
                                // 如果记录已存在，不再重复插入
                                XxlJobHelper.log("漏洞报告已存在，ID: " + existingReport.getId() +
                                    ", CVE: " + existingReport.getCveId() +
                                    ", 检测到的依赖库: " + labels);
                            }
                        } catch (Exception e) {
                            XxlJobHelper.log("数据库操作异常，CVE: " + vulnerabilityReport.getCveId() + ", 错误: " + e.getMessage());
                            e.printStackTrace();
                        }


                    try {
                        JsonNode whiteListJsonArray = objectMapper.readTree(currentWhiteListAsString);
                        //根据maxDetectNum做截断
                        List<String> labelList = Arrays.asList(labels.split(";"));
                        if (labelList.size() > maxDetectNum) {
                            labelList = labelList.subList(0, maxDetectNum);
                        }
                        // 遍历 JSON 数组
                        for (JsonNode WhiteList : whiteListJsonArray) {
                            String name = WhiteList.get("name").asText();
                            String pojectid = WhiteList.get("pojectid").asText();
                            if (labelList.contains(name)) {

                                Vulnerability vulnerability = new Vulnerability();
                                vulnerability.setDescription(vulnerabilityReport.getDescription());
                                vulnerability.setIsAccept(0);
                                vulnerability.setIsDelete(0);
                                // 使用漏洞名称而不是依赖库名称
                                vulnerability.setName(vulnerabilityReport.getVulnerabilityName());
                                vulnerability.setRiskLevel(vulnerabilityReport.getRiskLevel());
                                vulnerability.setTime(vulnerabilityReport.getDisclosureTime());
                                vulnerability.setLanguage(language);
                                vulnerability.setRef(vulnerabilityReport.getCveId());
                                vulnerabilityMapper.insert(vulnerability);


                                VulnerabilityReportVulnerability vulnerabilityReportVulnerability = new VulnerabilityReportVulnerability();
                                vulnerabilityReportVulnerability.setVulnerabilityId(vulnerability.getId());
                                vulnerabilityReportVulnerability.setVulnerabilityReportId(vulnerabilityReport.getId());
                                vulnerabilityReportVulnerability.setIsDelete(0);
                                vulnerabilityReportVulnerabilityMapper.insert(vulnerabilityReportVulnerability);


                                ProjectVulnerability projectVulnerability = new ProjectVulnerability();
                                projectVulnerability.setVulnerabilityId(vulnerability.getId());
                                projectVulnerability.setProjectId(Integer.parseInt(pojectid));
                                projectVulnerability.setIsDelete(0);
                                projectVulnerabilityMapper.insert(projectVulnerability);
                            }
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
        }

    }

    public static List<VulnerabilityReport> selectDodayvulnerabilities(List<VulnerabilityReport> vulnerabilities) {
        List<VulnerabilityReport> todaysVulnerabilities = new ArrayList<>();
        LocalDate today = LocalDate.now(ZoneId.of("Asia/Shanghai"));  // 设置为上海时区

        for (VulnerabilityReport vulnerability : vulnerabilities) {
            // 将 java.util.Date 转换为 LocalDate
            Date date = vulnerability.getDisclosureTime();
            LocalDate disclosureLocalDate = date.toInstant().atZone(ZoneId.of("Asia/Shanghai")).toLocalDate();

            if (disclosureLocalDate.equals(today)) {
                todaysVulnerabilities.add(vulnerability);
            }
        }

        return todaysVulnerabilities;
    }

}

//"net.java.openjdk.cacio:cacio;com.github.caciocavallosilano:cacio;org.apache.cactus:cactus"
