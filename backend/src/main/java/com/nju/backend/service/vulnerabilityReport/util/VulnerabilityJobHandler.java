package com.nju.backend.service.vulnerabilityReport.util;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.nju.backend.repository.mapper.*;
import com.nju.backend.repository.po.*;
import com.xxl.job.core.context.XxlJobHelper;
import com.xxl.job.core.handler.annotation.XxlJob;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.client.RestTemplate;

import java.text.ParseException;
import java.time.LocalDate;
import java.time.ZoneId;
import java.util.*;
import java.util.stream.Collectors;

@Component
public class VulnerabilityJobHandler {

    @Autowired
    private VulnerabilityReportMapper vulnerabilityReportMapper;

    @Autowired
    private CompanyMapper companyMapper;

    @Autowired
    private VulnerabilityReportVulnerabilityMapper vulnerabilityReportVulnerabilityMapper;

    @Autowired
    private ProjectVulnerabilityMapper projectVulnerabilityMapper;

    @Autowired
    private VulnerabilityMapper vulnerabilityMapper;

    static List<String> SupportedLanguages = Arrays.asList("java", "c");

    @Transactional
    @XxlJob("githubVulnerabilityFetchJob")
    public void fetchGithubVulnerabilityData() {
        try {
            RestTemplate restTemplate = new RestTemplate();
            String url = "http://localhost:5000/vulnerabilities/github";
            String jsonData = restTemplate.getForObject(url, String.class);

            List<VulnerabilityReport> vulnerabilities = parseJsonData(jsonData);
            //vulnerabilities  = selectDodayvulnerabilities(vulnerabilities);
            detectVulnerabilities(vulnerabilities);

            XxlJobHelper.log("Vulnerability data fetched and stored successfully.");
        } catch (Exception e) {
            XxlJobHelper.log("Error occurred while fetching vulnerability data: " + e.getMessage());
        }
    }

    @Transactional
    @XxlJob("avdVulnerabilityFetchJob")
    public void fetchAvdVulnerabilityData() {
        try {
            RestTemplate restTemplate = new RestTemplate();
            String url = "http://127.0.0.1:5000/vulnerabilities/avd";
            XxlJobHelper.log("Calling AVD API: " + url);
            System.out.println("DEBUG: Calling AVD API: " + url);
            String jsonData = restTemplate.getForObject(url, String.class);
            XxlJobHelper.log("AVD API response received, length: " + (jsonData != null ? jsonData.length() : "null"));
            List<VulnerabilityReport> vulnerabilities = parseJsonData(jsonData);
            XxlJobHelper.log("Parsed " + vulnerabilities.size() + " AVD vulnerabilities");

            // 调试输出前几条数据的漏洞名称
            for (int i = 0; i < Math.min(3, vulnerabilities.size()); i++) {
                VulnerabilityReport vuln = vulnerabilities.get(i);
                XxlJobHelper.log("AVD Vuln " + i + ": name=" + vuln.getVulnerabilityName() + ", cveId=" + vuln.getCveId());
                System.out.println("DEBUG: AVD Vuln " + i + " name=[" + vuln.getVulnerabilityName() + "] cveId=[" + vuln.getCveId() + "]");
            }

            detectVulnerabilities(vulnerabilities);

            XxlJobHelper.log("AVD vulnerability data processed successfully.");
        } catch (Exception e) {
            XxlJobHelper.log("AVD Error: " + e.getClass().getSimpleName() + " - " + e.getMessage());
            e.printStackTrace();
        }
    }

    @Transactional
    @XxlJob("nvdVulnerabilityFetchJob")
    public void fetchNvdVulnerabilityData() {
        try {
            RestTemplate restTemplate = new RestTemplate();
            String url = "http://localhost:5000/vulnerabilities/nvd";
            String jsonData = restTemplate.getForObject(url, String.class);

            List<VulnerabilityReport> vulnerabilities = parseJsonData(jsonData);
            //vulnerabilities = selectDodayvulnerabilities(vulnerabilities);
            detectVulnerabilities(vulnerabilities);

            XxlJobHelper.log("Vulnerability data fetched and stored successfully.");
        } catch (Exception e) {
            XxlJobHelper.log("Error occurred while fetching vulnerability data: " + e.getMessage());
        }
    }

    private List<VulnerabilityReport> parseJsonData(String jsonData) {
        ObjectMapper mapper = new ObjectMapper();
        try {
            return mapper.readValue(jsonData, new TypeReference<List<VulnerabilityReport>>() {
            });
        } catch (JsonProcessingException e) {
            e.printStackTrace();
            return Collections.emptyList();
        }
    }

    private void saveToDatabase(List<VulnerabilityReport> vulnerabilities) {
        if (vulnerabilities == null || vulnerabilities.isEmpty()) {
            XxlJobHelper.log("No vulnerability data to store.");
            return;
        }

        for (VulnerabilityReport report : vulnerabilities) {
            if (vulnerabilityReportMapper.selectById(report.getId()) == null) {
                vulnerabilityReportMapper.insert(report);
            } else {
                XxlJobHelper.log("Duplicate entry found for vulnerability: " + report.getVulnerabilityName());
            }
        }
    }

    @Transactional
    public void detectVulnerabilities(List<VulnerabilityReport> vulnerabilities) {
        List<Company> companies = companyMapper.selectList(null);
        for (VulnerabilityReport vulnerabilityReport : vulnerabilities) {
            for (Company company : companies) {
                for (String language : SupportedLanguages) {
                    RestTemplate restTemplate = new RestTemplate();
                    String url = "http://localhost:5000/vulnerabilities/detect";

                    ObjectMapper objectMapper = new ObjectMapper();
                    String currentWhiteListAsString = null;
                    try {
                        JsonNode whiteListJsonArray = objectMapper.readTree(company.getWhiteList());
                        // 筛选出language字段等于当前循环中的language的所有对象
                        List<JsonNode> currentWhiteList = objectMapper.convertValue(
                                        whiteListJsonArray,
                                        new TypeReference<List<JsonNode>>() {
                                        }
                                ).stream()
                                .filter(node -> node.has("language") && node.get("language").asText().equals(language))
                                .collect(Collectors.toList());
                        currentWhiteListAsString = objectMapper.writeValueAsString(currentWhiteList);
                        if ("".equals(currentWhiteListAsString)){
                            continue;
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }

                    // 创建要发送的参数
                    Map<String, String> params = new HashMap<>();
                    params.put("cve_id", vulnerabilityReport.getCveId());
                    params.put("desc", vulnerabilityReport.getDescription());
                    params.put("white_list", currentWhiteListAsString);
                    params.put("company", company.getName());
                    params.put("detect_strategy", company.getDetectStrategy());
                    params.put("similarityThreshold", company.getSimilarityThreshold().toString());
                    params.put("language", language);

                    // 设置HTTP头，指定内容类型为JSON
                    HttpHeaders headers = new HttpHeaders();
                    headers.set("Content-Type", "application/json");

                    // 创建HTTP实体，包含请求体和头信息
                    HttpEntity<Map<String, String>> requestEntity = new HttpEntity<>(params, headers);

                    // 发送POST请求并接收响应
                    ResponseEntity<String> response;
                    String labels;

                    try {
                        response = restTemplate.exchange(url, HttpMethod.POST, requestEntity, String.class);
                        labels = response.getBody();

                        // 检查响应状态和内容
                        if (!response.getStatusCode().is2xxSuccessful()) {
                            XxlJobHelper.log("API调用失败，状态码: " + response.getStatusCode() + ", CVE: " + vulnerabilityReport.getCveId());
                            continue; // 跳过这个公司的处理
                        }

                        if (labels == null || labels.trim().isEmpty()) {
                            XxlJobHelper.log("API返回空结果，CVE: " + vulnerabilityReport.getCveId() + ", 公司: " + company.getName());
                            continue; // 跳过这个公司的处理
                        }

                        // 检查是否返回了错误页面（HTML内容）
                        if (labels.contains("<!doctype html>") || labels.contains("<html")) {
                            XxlJobHelper.log("API返回错误页面，CVE: " + vulnerabilityReport.getCveId() + ", 公司: " + company.getName());
                            XxlJobHelper.log("错误详情: " + labels.substring(0, Math.min(200, labels.length())));
                            continue; // 跳过这个公司的处理
                        }

                        // 记录成功的API调用
                        XxlJobHelper.log("API调用成功，CVE: " + vulnerabilityReport.getCveId() + ", 公司: " + company.getName() + ", 语言: " + language + ", 返回标签数量: " + (labels.split(";").length));

                    } catch (Exception e) {
                        XxlJobHelper.log("API调用异常，CVE: " + vulnerabilityReport.getCveId() + ", 公司: " + company.getName() + ", 错误: " + e.getMessage());
                        e.printStackTrace(); // 打印完整异常堆栈
                        continue; // 跳过这个公司的处理
                    }

                    int maxDetectNum = company.getMaxDetectNums();


                        try {
                            // 获取当前ID对应的记录
                            VulnerabilityReport existingReport = vulnerabilityReportMapper.selectById(vulnerabilityReport.getId());

                            if (existingReport != null) {
                                // 如果记录存在，则更新其VulnerabilityName
                                String currentVulnerabilityName = existingReport.getVulnerabilityName();

                                // 处理可能为null的情况
                                if (currentVulnerabilityName == null) {
                                    currentVulnerabilityName = "";
                                }

                                // 清理字符串：去除首尾的空白字符和引号，并替换内部的换行符为空格或直接移除
                                currentVulnerabilityName = currentVulnerabilityName.trim().replace("\n", "").replace("\"", "");
                                // 分割并去重
                                String[] currentLibs = currentVulnerabilityName.isEmpty() ? new String[0] : currentVulnerabilityName.split(";");
                                Set<String> currentLibSet = new HashSet<>(Arrays.asList(currentLibs)); // 使用Set去重

                                // 清理新添加的labels，去除首尾空格、换行符和引号
                                labels = labels.trim().replace("\n", "").replace("\"", "");
                                String[] newLabelsArray = labels.split(";");

                                // 添加新label到集合中，同时去除每个label可能存在的前后空格
                                for (String label : newLabelsArray) {
                                    String trimmedLabel = label.trim();
                                    if (!trimmedLabel.isEmpty()) {
                                        currentLibSet.add(trimmedLabel);
                                    }
                                }

                                // 移除空字符串
                                currentLibSet.remove("");

                                // 将集合转换回字符串，并用;分隔
                                String updatedVulnerabilityName = String.join(";", currentLibSet);

                                // 更新现有报告中的VulnerabilityName
                                existingReport.setVulnerabilityName(updatedVulnerabilityName);

                                // 使用updateById根据实体对象的ID进行更新
                                int updateResult = vulnerabilityReportMapper.updateById(existingReport);
                                XxlJobHelper.log("更新漏洞报告，ID: " + existingReport.getId() + ", 更新结果: " + updateResult + ", 漏洞名称: " + updatedVulnerabilityName);
                            } else {
                                // 如果记录不存在，则设置新的VulnerabilityName并插入新记录
                                labels = labels.trim().replace("\n", "").replace("\"", "");
                                vulnerabilityReport.setVulnerabilityName(labels);
                                int insertResult = vulnerabilityReportMapper.insert(vulnerabilityReport);
                                XxlJobHelper.log("插入新漏洞报告，插入结果: " + insertResult + ", 漏洞名称: " + labels);
                            }
                        } catch (Exception e) {
                            XxlJobHelper.log("数据库操作异常，CVE: " + vulnerabilityReport.getCveId() + ", 错误: " + e.getMessage());
                            e.printStackTrace();
                        }


                    try {
                        JsonNode whiteListJsonArray = objectMapper.readTree(currentWhiteListAsString);
                        //根据maxDetectNum做截断
                        List<String> labelList = Arrays.asList(labels.split(";"));
                        if (labelList.size() > maxDetectNum) {
                            labelList = labelList.subList(0, maxDetectNum);
                        }
                        // 遍历 JSON 数组
                        for (JsonNode WhiteList : whiteListJsonArray) {
                            String name = WhiteList.get("name").asText();
                            String pojectid = WhiteList.get("pojectid").asText();
                            if (labelList.contains(name)) {

                                Vulnerability vulnerability = new Vulnerability();
                                vulnerability.setDescription(vulnerabilityReport.getDescription());
                                vulnerability.setIsAccept(0);
                                vulnerability.setIsDelete(0);
                                vulnerability.setName(name);
                                vulnerability.setRiskLevel(vulnerabilityReport.getRiskLevel());
                                vulnerability.setTime(vulnerabilityReport.getDisclosureTime());
                                vulnerability.setLanguage(language);
                                vulnerabilityMapper.insert(vulnerability);


                                VulnerabilityReportVulnerability vulnerabilityReportVulnerability = new VulnerabilityReportVulnerability();
                                vulnerabilityReportVulnerability.setVulnerabilityId(vulnerability.getId());
                                vulnerabilityReportVulnerability.setVulnerabilityReportId(vulnerabilityReport.getId());
                                vulnerabilityReportVulnerability.setIsDelete(0);
                                vulnerabilityReportVulnerabilityMapper.insert(vulnerabilityReportVulnerability);


                                ProjectVulnerability projectVulnerability = new ProjectVulnerability();
                                projectVulnerability.setVulnerabilityId(vulnerability.getId());
                                projectVulnerability.setProjectId(Integer.parseInt(pojectid));
                                projectVulnerability.setIsDelete(0);
                                projectVulnerabilityMapper.insert(projectVulnerability);
                            }
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
        }

    }

    public static List<VulnerabilityReport> selectDodayvulnerabilities(List<VulnerabilityReport> vulnerabilities) {
        List<VulnerabilityReport> todaysVulnerabilities = new ArrayList<>();
        LocalDate today = LocalDate.now(ZoneId.of("Asia/Shanghai"));  // 设置为上海时区

        for (VulnerabilityReport vulnerability : vulnerabilities) {
            // 将 java.util.Date 转换为 LocalDate
            Date date = vulnerability.getDisclosureTime();
            LocalDate disclosureLocalDate = date.toInstant().atZone(ZoneId.of("Asia/Shanghai")).toLocalDate();

            if (disclosureLocalDate.equals(today)) {
                todaysVulnerabilities.add(vulnerability);
            }
        }

        return todaysVulnerabilities;
    }

}

//"net.java.openjdk.cacio:cacio;com.github.caciocavallosilano:cacio;org.apache.cactus:cactus"
